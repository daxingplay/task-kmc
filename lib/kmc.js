var Execution = require('execution');
var path = require('path');
var glob = require('glob');
var os = require('os');
var file = require('easyfile');
var fs = require('fs');

module.exports = Execution.extend({
    // The type of option could be HTML5 input types: file, directory, number, range, select,
    // url, email, tel, color, date, time, month, time, week, datetime(datetime-local),
    // string(text), boolean(checkbox), array, regexp, function and object.
    options: {
        name: {
            label: 'Package name',
            type: 'string'
        },
        src: {
            label: 'Src file',
            type: 'string'
        },
        dest: {
            label: 'Dest file',
            type: 'string'
        },
        combo: {
            label: 'Generate modules with online combo mode to dest dir',
            type: 'boolean'
        },
        dep: {
            label: 'Generate all online combo mode modules dependence config in dependence config file',
            type: 'string'
        },
        base: {
            label: 'Combo src base'
        },
        packages: {
            label: 'KISSY package config',
            type: 'object'
        },
        charset: {
            label: 'File charset',
            type: 'string',
            default: 'utf8'
        }
    },
    run: function (inputs, options, logger, settings) {
        return this._run(inputs, options, logger, settings);
    },
    execute: function (resolve, reject) {
        var options = this.options;
        var inputs = this.inputs;
        var logger = this.logger;
        var packages = options.packages || {};
        var name = options.name;
        var src = path.resolve(options.src);
        var dest = path.resolve(options.dest);
        var base = path.resolve(options.base || '');
        var dep = options.dep && path.resolve(options.dep);
        var charset = options.charset;
        var combo = options.combo;

        logger.log('Build KISSY modules with', src);

        var defaultPackage = {
            name: name,
            path: path.dirname(src),
            // hack for kmc
            base: path.dirname(src),
            ignorePackageNameInUri: true
        };

        if(Array.isArray(packages)){
            packages.push(
                defaultPackage
            );
        }else if(name && !packages[name]){
            packages[name] = defaultPackage
        }

        var kmc = require('kmc');
        kmc.config({
            packages: packages
        });

        if(combo){

            var dependenciesResults = [];

            glob.sync(src).forEach(function(inputFile){
                // /path/to/src/file
                inputFile = path.resolve(inputFile);
                var destFile = path.join(dest, path.relative(base, inputFile));
                // create a backup because combo will rewrite source file
                // var backup = fs.readFileSync(inputFile);

                file.copy(inputFile, destFile);

                // Only do module name fix
                var depenences = kmc.combo(
                    destFile, // inputFile
                    undefined, // depFileName
                    charset, // depFileCharset
                    true, // fixModuleName
                    true, // returnDependencies
                    null, // outputDir
                    true // comboOnly
                );

                // fs.writeFileSync(inputFile, backup);

                logger.log('File', inputFile, 'module name fixed generated to', destFile);

                dependenciesResults.push(depenences);
            });

            if(dep){
                var content = [];
                var writed = [];
                dependenciesResults.forEach(function(result){
                    if(result.modules){
                        for(var modName in result.modules){
                            if(writed.indexOf(modName) === -1){
                                var mod = result.modules[modName];
                                var requires = [];
                                if(mod && mod.dependencies && mod.dependencies.length){
                                    mod.dependencies.forEach(function(subMod){
                                        requires.push("'" + subMod.name + "'");
                                    });
                                    content.push("'" + modName + "': { requires: [" + requires.join(', ') + "]}");
                                }
                                writed.push(modName);
                            }
                        }
                    }
                });
                var mapResults = '/* Generated by task-kmc */' + os.EOL;
                if(content.length){
                    mapResults +=  "KISSY.config('modules', {" + os.EOL + " " + content.join("," + os.EOL + " ") + " " + os.EOL + "});";
                }

                file.write(dep, mapResults, {
                    encoding: charset
                });

                logger.log('Modules config file ' + dep + ' generated')
            }


        }else{

            kmc.build({
                src: src,
                dest: dest,
                depPath: dep
            });

            logger.log('File ' + dest + ' generated')
        }

        resolve(inputs);
    }
})
